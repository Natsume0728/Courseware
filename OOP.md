# OOP

<!-- TOC depthFrom:2 orderedList:false -->

- [封装](#封装)
- [继承](#继承)
- [多态](#多态)

<!-- /TOC -->
<!-- - [封装](#封装)
- [继承](#继承)
- [多态](#多态) -->

>面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。  
OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。  
面向对象是为了大量数据的维护和使用方便,实际开发种都是用面向对象方式开发程序。  
__面向对象三大特点: 封装 继承 多态__  
>>对象：描述现实中一个具体事物的属性和功能的一种程序结构；
本质是给内存中可存储多个数据或函数的的存储空间，再起一个名字。

## 封装

1. 用{ }
1. 用new: 2步:  
     1. 先创建一个空对象:  
    var obj=new Object();==>{ }
     2. 用强行赋值的方式添加新属性:  
    obj.新属性=值  
     obj.新方法=function(){ ... }  
__揭示了一个js最底层的原理:js中一切对象底层都是关联数组。__  
VS关联数组:  
        1. 访问关联数组成员: 2种:  
            - 对象["属性名"]  比如: ym["math"]  
            - 对象.属性名     比如: ym.math  
     固定用法: 如果属性名是动态获得，不是写死的，就必须用[ ]方式获得属性值，且不能加""  
      比如:  
      for(var name in obj){  
          console.log(obj[name])  
             }  
        2. 访问不存在的成员: 不报错，而是返回undefined  
        3. 强行给不存在的成员赋值: 不报错，自动添加新成员  
           所以，今后向对象中，临时添加新成员，都用强行赋值的方式。
        4. 遍历: 关联数组可用for in循环遍历  
            对象中的成员也可以用for in遍历  
笔试题：克隆对象(对象的深拷贝)  
  什么是克隆对象: 照着原对象的成员结构，再创建一个新的一模一样的对象。  
  何时: 不希望别人直接使用原对象时，保护原对象  
  如何: 3步:  
            1. 先创建一个空对象
            2. 遍历原对象中的每个属性
    每遍历一个原属性，就向新对象中添加同名属性，值也和原属性值相同。
            3. 返回新创建的对象.  
__前两种方式的问题: 一次只能创建一个对象。如果反复创建多个相同结构的对象时，代码会很繁琐__
1. 用构造函数，反复创建多个相同结构的对象  
    什么是构造函数: 专门描述一类对象的统一成员结构的函数  
    为什么: 重用结构  
    何时: 当需要反复创建相同类型的多个对象时  
    如何: 2步:  
    1. 先定义构造函数，规定一类对象的统一结构  
      function 类型名(属性参数列表){  
        //有几个属性，就要同时定义几个形参  
        this.属性名=xx;  
        this.属性名=xx;  
        this.方法=function( ){  
          ... this.属性名  
        }  
      }  
    2. 用new调用构造函数，照图施工，创建新对象  
      var obj=new 类型名(属性值列表)  
          function 类型名(属性形参列表)  
      原理: new做了4件事:  
       1. 创建一个新对象
       2. 将新对象的_proto_指向构造函数的prototype对象
       3. 将构造函数的作用域赋值给新对象 （也就是this指向新对象）  
          执行构造函数中的代码（为这个新对象添加属性）。
       4. 返回新对象的结果  

问题: 如果将方法的定义放在构造函数内，那么，每创建一个新对象，都会创建方法的副本——浪费内存
   解决:继承
  
## 继承

   什么是: 父对象的成员，子对象无需重复创建，就可直接使用。  
   为什么: 节约内存，代码重用  
   何时: 只要多个子对象，拥有相同的属性值或方法定义时，都应该在父对象中定义一次。所有子对象共用！  
   如何: js中都是通过原型对象的机制来实现继承  
    什么是原型对象: 集中存储多个子对象，共有成员的父级对象。  
    何时: 只要为多个孩子定义统一的方法定义或属性值时，都要定义在原型对象中。  
    如何:  

1. 原型对象不用自己创建: 买一赠一  
  每当创建一个构造函数时，都会附赠一个空的原型对象  
  可通过构造函数的prototype属性找到，当前构造函数对应的原型对象  
  比如: Student.prototype  
2. 如何让孩子继承爹: 自动的  
  new的第二步是设置新对象的爹/原型继承构造函数的原型对象。  
  所有子对象都有一个_ _proto_ _属性指向构造函数的原型对象  
  凡是从_ _proto_ _指出的关系，都是继承关系。  
  比如: lilei._ _proto_ _=Student.prototype  
3. 如何利用继承关系，优化代码: 需要自己做  
  凡是多个子对象共用的成员方法或属性值，都要定义在构造函数的原型对象中——通过强行赋值的方式  
  比如: Student.prototype.intr=function(){ ... }  
  结果：所有孩子可以共用！  
__总结:__  
 将来要定义构造函数时:  
   1. 所有的属性，都定义在构造函数中
    所有定义在构造函数中的属性，将来都会创建到子对象中。
    子对象中有什么属性，取决于构造函数中有什么属性
   2. 所有的方法，都要强行添加到构造函数的原型对象中
    构造函数中有多少个方法，子对象就能使用多少功能。

   内置类型也都有构造函数和原型对象:  
    内置类型: Array  Date   RegExp   Function  ... ...  
      比如:  
      Array:  
        构造函数     +    原型对象  
      function Array( ){      Array.prototype原型对象  
        ... ...               sort()  join() ... ...  
      }  
      才能 new Array()  
      反例: Math不能new，因为不是构造函数  
      var arr1=[];   arr1.sort();   arr1.join()  
      var arr2=[];   arr2.sort();   arr2.join()  
   如果内置类型中的原型对象中的方法不够用，可自己向原型对象中添加共有方法  
    比如:  
    希望给所有数组都添加一个共有的方法sum()，可对当前数组中的所有元素求和:  
     Array.prototype.sum=function(){  
       ... this->将来调用sum()的.前的数组对象 ...  
     }  
     比如:  
     var arr1=[1,2,3];  
     var arr2=[1,2,3,4,5];  
     console.log(  
      arr1.sum(),//6  
      //this->.前的arr1  
      arr2.sum() //15  
      //this->.前的arr2  
     );  
__原型链:__  
   什么是: 由多级原型对象组成的链式结构  
   原理:  
    1. 所有对象都有\_ \_proto_ _属性指向自己的爹  
    2. Object类型(function Object( ){ }和Object.prototype是所有对象的顶级父类型)  
    3. 只要在自己的原型链上的方法，自己都能用  
       只要不在自己的原型链上的方法，自己都不能用  
    强调: __因为爸爸和妈妈之间没有继承关系，所以子对象用不了姥爷中的方法__  

## 多态

   什么是多态: 同一个函数在不同情况下表现出不同的状态  
   包括2种情况:  
    1. 重载:  
    2. 重写(override)  
     什么是: 子对象中定义和父对象同名的成员  
     何时: 只要爹的不好用，就自己定义自己的  
     如何: 只要在子对象中，定义和父对象同名的成员  
      后果: 使用时，先用自己的。不再用父对象继承来的  
     建议: 所有自定义类型: Student或定义对象var lilei={ }，都应该重写toString( )方法便于调试  

__总结:__  
 三大特点： 封装，继承，多态  

- 封装:  
  创建对象: 2种  

   1. 如果只创建一个对象，不会反复创建:  
     首选: var obj={ ... ... }
   2. 如果反复创建多个相同结构的对象时:  
     首选构造函数: 2步:  
       1. 定义构造函数:  
         function Student(sname,sage){  
           this.sname=sname;  
           this.sage=sage;  
           //不能将方法定义放在构造函数中  
         }  
       2. 用new 调用构造函数：  
         var lilei=new Student("Li Lei",11);  
- 继承:  
所有子对象共有的方法，应该添加到构造函数的原型对象中  
    用子对象调用方法时，先在子对象本地查找。  
    如果自己没有，才延原型链向父级对象查找。直到找到为止。  
    强调: __原型对象中的方法中的this指将来调用该方法的.前的某个子对象。__  
- 多态:  
重写: 如果从父对象继承来的方法不好用，可在子对象本地定义同名方法，覆盖父对象中的不好用的方法。

补充内容:  
__按值传递__，没有按引用传递  
 什么是: 当两个变量间赋值时，只是将原变量中的值赋值一个副本给对方。  
 两个后果:  

1. 基本类型/原始类型: number  string  boolean ...  
赋值是将原变量中的值本身复制一个副本给对方  
修改新变量，原变量不受影响  
2. 引用类型: 对象，数组，。。。  
赋值只是将变量中保存的对象地址，复制一份给新变量。  
对象并没有创建一个新的。还是只有一个对象  
只不过两个变量用相同的对象地址，指向同一个对象而已。  
任何一方修改对象，另一方，同时受影响。

__总结：this的指向__ 问题

1. obj.fun() fun()中的this->.前的obj
2. fun() fun()中的this->默认指window
   window.fun()
3. new fun() 中的this->新对象
4. Array.prototype.sum=function(){  
   this-> 将来调用sum的.前的任意数组对象！  
  }
