# ES6

- [let](#let)
- [箭头函数](#箭头函数)
- [for of](#for-of)
- [参数增强](#参数增强)
- [解构](#解构)
- [class 面向对象](#class)
- [promise](#promise)

## 模板字符串

>略

## let

> 专门代替var，声明变量  

var有两个广受诟病的缺陷:  

1. 声明提前——打乱了正常的执行顺序
2. 没有块级作用域——块内和块外的变量就会互相干扰

let的特点:  

1. 用let声明的变量不会被提前，也就不能提前使用  
如果提前使用报错:  
`Cannot access 'a' before initialization//不能在a初始化之前，访问a`  
在函数内:  
let a=xx之前，到function(){内部，这片区域是变量a的禁区。  
决不允许使用变量a。即使有全局变量a，也会报错！  
所以，如果局部变量和全局变量重名时，必须有一个变量要改名以示区分。
2. 添加了块级作用域:  
块级作用域: if( ){}   while( ){}    for( ){}  ...  
凡是这些块级作用域中的变量，都自成体系，不会影响外部！  
原理: __let相当于匿名函数自调！__

## 箭头函数: 代替一切函数定义：普通函数定义，匿名函数自调，回调函数

口诀：  

 1. 去function 变为 ( )=>{ ... }
 2. 如果只有一个形参，可省略( )  
 3. 如果函数体只有一句话，则可省略{ }  
但 __如果仅有的一句话是return，则必须去掉return__ ;  

箭头函数特点:  
让内部this和外部this保持一致！  
只要希望回调函数内的this，和外部的this保持一致时，就可将回调函数改为箭头函数。让内部this与外部this保持一致！  
但是，__如果就是希望函数内的this与函数外的this不同时，就不能改成箭头函数！__  
比如: __对象中的方法不能改成箭头函数__

## for-of

> 专门简化for循环，遍历数组  

__遍历索引数组: 3种:__  

   1. 普通for:  
   `for(var i=0;i<arr.length;i++)`  
    使用场景: 任何情况都可以使用  
    顺序  倒叙  依次递增，也可以2,4,6  也可以5 10 15 20
   2. forEach:  
   `arr.forEach((elem,i,arr){ ... })`  
    使用场景: 即获得元素的内容，又需要使用元素的位置时  
    局限:__只能从头到尾，依次遍历！__  
   3. for of:  
    使用场景: 仅关心每个元素的内容，不关心位置时  
    `for(var elem of arr){...}`  
      of会依次取出arr中每个元素的内容  
      局限: __无法获得当前正在遍历的位置__  

>以上三个专门遍历索引数组,遍历关联数组或对象，必须用for in;  
__for in只能遍历关联数组，不能遍历索引数组：__  
in的本意是找属性的意思，且不仅找自有属性，还找原型链上的共有属性。

## 参数增强  

1. 默认值: default  
    ES6中可以给最后一个形参，定义默认值  
    如调用函数时，没有给定最后一个实参值，则自动使用默认值代替  
    如何:  
    在函数定义时:  
     `function fun(形参1,...,形参n=默认值){ }`  
     调用时:  
      `fun(实参1,...缺实参n)`自动用默认值代替;
2. 剩余参数: rest  
     专门代替arguments,想用arguments的地方，都可用剩余参数代替  
     arguments的缺点：
   1. 不是纯正的数组，是类数组对象  
        数组函数，arguments一个都不能用
   2. 只能获得全部，不能有选择的获得部分实参值  

     使用场景: 定义函数时:  
function fun(固定形参1,固定形参2,...数组名){  
//数组中会接住除前两个固定形参之外的所有剩余实参值。——是纯正的数组  
             }  
优势: rest语法:  
    1. 是纯正的数组，数组的函数，都可使用  
    2. 可有选择的获取部分想要的实参值。

3. 打散数组: spread  
   传统js中: 可用apply( )打散数组为当值，再传入函数。  
   问题: apply( )的本职工作是替换this，然后顺便打散数组。  
   而实际需求中，多数情况仅打散数组，而与this无关。  
     比如: 本意从数组中找出最大值  
       Math.max.apply(null, arr)  
   解决: 调用函数时:  
     Math.max(...arr)//拆

## 解构  

>destruct：将一个大的对象/数组中的成员，提取出来，单独使用。

使用场景:只要仅使用一个大的对象/数组中的一小部分成员时  

   1. 数组解构: 从数组中取出个别元素，单独使用  
     如何: 下标对下标  
      var date=[2019,6,7,8,30,0];  
           var [y]=date;  
      y=2019;  
      var [     , , ,h,m,s]=date;  
      h=8, m=30, s=0
   2. 对象解构: 从一个大的对象中提取出想要的个别成员单独使用:  
    如何: 属性对属性:  
     var 对象={  
       属性1: 值1,  
         ... : ... ,  
       方法1: function(){ ... },  
       方法2: function(){ ... }  
     }  
     //比如只想用属性1的值和方法1函数  
     var {属性1: 变量1, 方法1: 变量2}=对象  
     结果:  
     变量1=值1,  
          变量2=方法1function(){ ... }  
     如果属性名和要用的变量名一致，可简写为:  
      var {属性1, 方法1}=对象:  
      结果: 属性名即当做配对，又作为提取出来之后的变量名使用。

   3. 参数解构: 将所有参数放在一个对象中传入:  
    问题: 如果多个形参都不确定有没有时，既不能用默认值解决(只能用在最后一个参数)，又不能用rest解决(rest只能用在末尾的多个形参)  
    解决: 必须用参数解构： 2步  
      1. 定义函数时，就将所有的形参都以名值对的方式定义在一个对象中
      2. 调用函数时，所有实参也必须以名值对的方式，放在一个对象中整体传入。

## class

1. 对{ }中对象成员的简化:  
    1. 如果对象中的属性值来自于外部变量，且变量名刚好等于属性名: 可简写为只写一个名字:  
      var ip="127.0.0.1";  
      var port=3306;  
      var dbconfig={  
        ip, //ip: ip,  
        port, //port: port  
      }  
    2. 对象方法的简写:  
      var lilei={  
        sname:"Li Lei",  
        sage: 11,  
        intr(){  //intr: function(){  
          ...this.sname...this.sage...  
        }  
      }  
2. 对构造函数和原型对象的封装:  
   旧js: 构造函数和原型对象是分开定义的，不符合封装的要求。  
   ES6:  
    1. 用class{ } 包裹构造函数和原型对象方法  
    2. 构造函数名提升为类型名，跟在class后
         今后所有构造函数名统一称为constructor；
    3. 所有原型对象方法可:  
         去掉"类型名.prototype.前缀"  
          class认为，直接保存在class内的方法，默认就是保存在原型对象中的  
         去掉"=function"  
    比如:  
    class Student{  
      //function Student(sname,sage){  
      constructor(sname,sage){  
        this.sname=sname;  
        this.sage=sage;  
      }  
    // Student.prototype.intr=function(){  
      intr(){  
        console.log(\`I'm ${this.sname}, I'm ${this.sage}`)  
      }  
    }  

## Promise

>专门为了解决回调地狱的问题  

  场景: 多个异步函数，要求必须同步执行  
  回调地狱: 见视频  
  解决: Promise技术：见视频  
