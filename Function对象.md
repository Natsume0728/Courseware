# Function对象

<!-- TOC depthFrom:2 orderedList:false -->

- [Function对象的定义及使用](#function对象的定义及使用)
- [重载](#重载)
- [匿名函数](#匿名函数)
- [作用域和作用域链](#作用域和作用域链)
- [闭包](#闭包)

<!-- /TOC -->
<!-- - [Function对象的定义及使用](#Function对象的定义及使用)  
- [重载](#重载)  
- [匿名函数](#匿名函数)  
- [作用域和作用域链](#作用域和作用域链)  
- [闭包](#闭包)   -->

## Function对象的定义及使用

什么是: 内存中保存一段可重用的代码段的对象，再起一个名字。  
 为什么: 重用！  
 何时: 如果一段代码段需要反复使用，就应该保存在一个函数中，反复调用函数。  
 如何:  
  创建: 3种方式  

   1. 声明方式:  
     function 函数名(形参列表){  
       函数体;  
       return 返回值;  
     }  
     问题: 声明提前  
     在程序开始执行前，会自动将所有var声明的变量和function声明的函数，  
     都提前到当前作用域的顶部，集中创建，__赋值留在原地__。
   2. 用赋值的方式:  
     var函数名=function (形参列表){  
       函数体;  
       return 返回值;  
     }  
     优点: __仅函数名提前，函数体留在原地。__  
     __揭示了函数的重要秘密__:
      1. 函数名本质就是一个普通的变量
      2. 而函数定义其实是一个对象(独立的存储空间)
   3. 用new创建:  
     var fun=new Function("形参","形参",...,"...")  

  调用:  
  var 返回值=函数名(实参值列表)  
   __调用函数，等效于执行函数中的代码段__  
   调用几次，就重复执行几次  
   __如果不调用，是不会执行函数的内容的__。  
  
## 重载

  什么是重载(overload):  
  相同函数名不同形参列表的多个函数，在调用时，可根据传入实参的不同，自动选择匹配的函数调用。  
  为什么: 调用不方便！  
  何时: 同一件事，根据传入实参的不同，自动选择不同的执行过程执行时。  
  如何:  
    问题: js语言不支持多个同名函数同时存在，所以默认和不支持重载。  
    解决: 借助: arguments  
     什么是arguments:  
     每个函数中自动包含的可直接使用的接收所有传入函数实参值列表的 __类数组对象__  
       类数组对象是: 长得像 数组的 对象  
       VS 数组:  

- 相同: 1. 下标, 2. length, 3. for遍历  
- 不同: 根本不同 类型不同 导致arguments不能使用数组家的任何函数。

## 匿名函数

  什么是: 创建函数时，不指定函数名  
  为什么: 2大作用:  

1. 节约内存
2. 避免全局污染  

何时: 2种:  

1. 只要一个函数只使用一次  
2. 划分临时作用域的时候，避免全局污染  

如何: 2种:  

1. 回调函数: 虽然我们自己定义的，但是不是我们自己调用执行的函数。  
 比如:  
 arr.sort(function(a,b){return a-b})  
      str.replace(/\b[a-z]/g, function(kw){ return ... })  
 都是为了节约内存！  
2. 匿名函数自调: 创建函数后，立刻调用函数  
 (function(){  
   var t=new Date();  
   document.write("\<h1>页面加载完成，at: "+t.toLocaleString()+"\</h1>")  
 })();  
 创建函数后，自己调用自己  
 优点: 不但自己调用后释放，且函数内的局部变量调用后，也会自动释放。  

总结:  

1. 今后所有js代码都要写在匿名函数自调中  
2. 今后禁止使用全局变量： 浪费内存 全局污染  

## 作用域和作用域链  

- 作用域(scope):  
    用法: 一个变量的可用范围  
    本质: 保存多个变量的内存空间  
  为什么: 为了保护不同范围的变量间不互相干扰  
  包括: 2种:  

    1. 全局作用域: window对象  
      凡是不在函数内创建的变量和函数都自动加载全局作用域    (window)中保存  
    2. 函数作用域:  
      函数作用域仅在调用函数时临时创建  
      所有函数内定义的变量和内层函数，都自动保存在临时的函数作  用域中  
      一旦函数调用后，临时的函数作用域及其内部的局部变量一起释  放！  
     VS Java:  
java有三级作用域:  
全局作用域  
函数作用域  
局部作用域:  
for() { ... }  
if(){ ... } else { ... }  
while(){ ... }  
如果在大括号内声明的变量出了{}，都不能用。  
              但js中，出了{ }还能用  
- 作用域链: scope chain  
    什么是: 由多级作用域组成的链式内存结构  
    原理:  
     每个函数都有一个隐藏的属性scopes  
     不调用函数时scopes只包含window的引用，指向全局作用域。  
     调用函数时，创建临时作用域对象，并将临时函数作用域对象的引用地址添加到scopes中，window之前。  
     调用时优先使用临时函数作用域中的变量，如果函数作用域中没有，才去全局window中找。如果都找不到，才会报错。  
     调用后: 函数作用域会被释放，函数作用域中的局部变量也就释放！  

## 闭包

  什么是: 即重用一个变量，又保护变量不被篡改  
  为什么:  
   全局变量: 优: 可重复使用。缺: 易被污染。  
   局部变量: 优: 仅函数内可用。缺: 不可重用。  
  何时: 当一个函数需要拥有一个可重用的专属的变量时  
  如何: 给函数和变量找一个共同的父母函数  
   3步:  

   1. 定义外层函数包裹内层函数和要保护的变量  
     问题: 原来全局的函数，现在变成局部的函数了，外边用不了了  
   2. 外层函数将内层函数抛出到外部！  
     问题: 外层函数如果不调用，是不执行的  
   3. 使用者调用外层函数，获得外层函数返回的内层函数保存在变量中。  
   结果: 使用者可反复调用保存在变量中的内层函数  
   function parent(){//1,  
    var total=1000;//要保护的变量  
    return function(money){//2,内层函数  
    total-=money;  
    document.write(\`本次花了${money}元，还剩${total}元\<br>\`)  
    }  
  }  
//3. 使用者调用外层函数，返回内层函数的对象，使用者用自定义的变量接住返回的内层函数对象。  
  var child=parent();  
  __鄙视题: 闭包如何形成:__  
   外层函数parent调用后，外层函数的作用域被内层函数引用着，无法释放。  
   外层函数的作用域，因为是保存在内层函数的私密的scopes通讯录里，所以外人都不知道！  且通过全局，绝对无法修改。  
  鄙视时: 画简图,找两样东西:
        1. 外层函数共向外返回了几个内层函数
        2. 那个变量是受保护的变量（给孩子包的红包）  
  再比如:  
   function fun(){  
    var n=999;  
    //任何位置，给不存在的变量强行赋值，结果自动在全局创建！  
        //生    孩子1  
    nAdd=function(){n++};  
    //生    孩子2  
    return function(){  
        console.log(n)  
    }  
   }  
    var getN=fun();  
    //生了两个孩子: getN和nAdd  
    //包了一个红包，两个孩子共用  
    getN();//获取红包金额  999  
    nAdd();//将红包+1  
    getN();//获取红包金额 1000  

  闭包的缺点: 闭包比普通的函数多占用一块内存！  
    多占用外层函数的作用域对象，不能释放  
  解决: 释放闭包: 2种方法  

   1. 给child变量赋值为null  
     变量child依然在内存中
   2. 删除child:  delete window.child  
     前提: child变量使用window.添加的。  
  __鄙视题:__  
  var a=10; window.a=10; window["a"]=10;差别  
    相同: 都是向全局添加一个全局变量a=10  
    不同: var a不能用delete删除  
         window.a和window["a"]可用delete删除  
    __总结: 将来就算被迫用全局变量，也必须用window.强行添加！__

__补充内容__:  
js中向数组中一个不存在的位置强行赋值:  
    不会报错，而是自动添加该新元素  
   比如:  
   var arr=["亮","然"]  
        arr[6]="东" //不报错  
        结果: arr中6号位置，会自动添加东:  
          arr:[ 0:"亮",1:"然",6:"东"]  
   __因为js中对象底层都是关联数组__，  
   所以，__强行向对象中一个不存在的属性赋值，结果，会自动添加该属性。__  
   比如:  
   window.child=xxx;  
     结果: 会在window中自动添加一个变量child,且child可被delete删除.
